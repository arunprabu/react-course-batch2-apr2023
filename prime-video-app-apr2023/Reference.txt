Webapps 
----
  1. Server Side Rendering Apps (SSR) / Traditional Webapps 
      * Pages will Refresh 

      Arch 
      ----
        1 Server -- PORT 8080 -- localhost:8080
        Response: HTML, CSS, JS + Data

      Codebase 
      -----
        HTML, CSS, JS + Back End + DB Queries 

      Adv 
      ----
        
      Disadv
      -----
        1. Server has to do the heavy-lifting of going thru html, css, js 
        2. Slower Webapps 
        3. Higher Bandwidth consumption
        4. Expensive 
        5. Offers Bad User Experience

  2. Client Side Rendering Apps (CSR) / Modern Webapps 
      * Pages will NOT Refresh 

      CSR = SPA + RESTful API 

      Arch 
      ----
        2 Servers 
          1 Front End App  -- Port 3000  -- localhost:3000 (end-user facing)
            Response: HTML, CSS, JS, (Wait for data in JSON)

          1 Back End App -- Port 8080  --- localhost:8080 
            Response: Data (JSON)

      Codebase 
      -----
        1 Front End App a.k.a Single Page Apps (SPA)
          HTML, CSS, JS  

        1 Back End App a.k.a RESTful API 
          Back End + DB Query 

      Adv
      ----
        1. Workload is shared between two servers and also client 
        2. Faster Webapps 
        3. Lesser Bandwidth consumption
        4. Not Expensive 
        5. Offers Better User Experience

      Disadv
      -----
      

Single Page App (SPA) Characteristics (7)
---------------
  1. Pages should Not Refresh 
  2. URL should be changed 
  3. History should be maintained without Page Refresh 
  4. Header and Footer should be intact. 
  5. The section in between header and footer should be updated 
  6. Active Menu should be set 
  7. Page Title should also be changed 

  SPA Frameworks / Libraries 
  ---------------------------
    #1 React JS (Library) 
    #2 VueJS (Framework)
    #3 Angular (Framework)

==========


Naming Conventions & Casing 
----
  Casing Types 
  --------
    1. PascalCase 
        * Recommended for Object Oriented Program's classes 
        * also Recommended for Interface in Java & TypeScript 
        * Recommended for React Components and the folder of Components

        examples 
        ---
          class CarDetails {

          }

          interface Employee {

          }

    2. camelCase 
        * Recommended for variables, const, functions, methods in JS & TS 
        * Recommended for id's of html elements 
        * Recommended for variables, const, fn, methods, event handlers of React Component
        
        examples 
        -----
          var myCar = 'BMW';

          function getCarInfo() {
            //....
          }
    
    3. kebab-case
        * Recommended for URLs 
        * Recommended for file names, folder names, assets in front end projects  
        * Recommended for css classes 
        * okay for id's of html elements if your architect says ok

        examples 
        -----
          btn-primary
          slideshow-container 
          youtube-logo.png 

    4. snake_case 
        * never ever use this. 
        * okay for const in JS & TS if architect accepts

        examples
        ---
          const MAX_STUDENTS_PER_CLASS = 30;

----------------

Thinking in React
----------
  0. Find out the number of components 
  1. Break the UI into component hierarchy 
  2. ...
  3. ...
  

Components
----------
  1. Functional Components  (should be created in src/components/)
      * Coded with JS functions 
      * were called as Dumb components / presentational components / stateless components (before 2019 - react v16.8)
      * after 2019 -- no longer called as dumb/presentational/stateless 
      * from react v 16.8 -- we can have fn components -- via hooks concepts

      1.1 Functional Component with Named Function [DONE]
      1.2 Functional Component with Anonymous Function [DONE]
      1.3 Functional Component with Arrow Function [DONE] [RECOMMENDED]

  2. Class Components  (should be created in src/containers/)
      * code as JS class but it must extend React Component class 
      * were called as Smart Components / containers / stateful components (before 2019 - react v16.8)
      * after 2019 -- no longer called as smart/stateful -- because both type of comp can have state 
      * can have LifeCycle hooks 


Project Structure
-----------
  src/
    components/
      Header/
        Header.js
        Header.css 
        Header.test.js 
      Footer/
        Footer.js 
        Footer.css  
        Footer.test.js 
      MenuList/
        MenuList.js 
        MenuList.css 
        MenuList.test.js 
    containers/
    pages/       (or features/)
      HomePage/
        LatestVideo/  
          LatestVideo.js
        TrendingVideoList/
          TrendingVideoList.js 
        RecommendedVideoList/
          RecommendedVideoList.js
        Subscription/
          Subscription.js 
        HomePage.js 
      AboutPage/


JSX Limitations
---
  * will look like HTML but not HTML
  * You can use all html tags. But tags must be closed. 
  * class attribute should become className
  

Integrating Third party packages / tools 
----------


Data Binding 
----
  * keep the data in comp and display it in JSX 
  1. One Way Binding [DONE]
      keep the data in a variable in comp's JS and display it in JSX 
  
  2. Two Way Binding 
      have the data in a variable,  display it in JSX and 
      update the variable's data and see the changes in JSX 

Sharing the data between components a.k.a Cross Component Communication
------
  1. Parent to Child Component Communication [DONE]
      using Props

  2. Child to Parent Component Communication [TODO]
      Using Props with callback function and event

  3. Any to Any Component Communication
      3.1 Using React Context API (or) [after the year 2019 - ReactJS v 16.8]
      3.2 Using ReduxJS / Flux / MobX


Concepts
---
  data binding [DONE]
    variables 

  props [DONE]
  states [DONE]
  events  [DONE]
  lists and keys [DONE]
  conditionals [DONE]

  [PENDING]
  
  Styles [.5 hour]
  LifeCycle Hooks [2 hours ]
  Routing[~1 hour]
  forms [1 hour]
  
  Hooks [12 hours]
  Adv react concepts [4-5 hours]
    .... 
    HOC 
    Fragments 
    StrictMode 
    Debugging & Error Boundary
  AJAX calls using fetch, axios [1 hour]
  Unit Testing [20-24 hours]
  Build and Deployement [~5 hour]
    Code-Splitting
    Lazy Loading 
  and many more...

  Redux 


----



